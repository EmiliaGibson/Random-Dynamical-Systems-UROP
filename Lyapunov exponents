# Top Lyapunov exponent 

#Method 1 using stationary measures
def top_lyap(μ, E, Ω, M):
    """
    parameters:
    μ : stationary measure of a 1d map f : Ω x M to M
    E : map E_w(ln|df/dx)|) from Ω x R to R
    Ω : interval in R from which noise values are drawn uniformly
    M : interval in R
    output:
    float
    """
    #normalize μ 
    μ = np.abs(μ)/np.sum(μ)
    res = len(μ)
    
    x = np.linspace(M[0], M[1], res)
    if Ω[0] == 0:
        g = 1/(Ω[1]-Ω[0])*(E(Ω[1],x))
    else:
        g = 1/(Ω[1]-Ω[0])*(E(Ω[1],x)-E(Ω[0],x))
        
    y = g*μ
    
    return np.sum(y)  



# example for a random logistic map

def f(w,x):
    """
    map from Ω ⊆ [0,4] x [0,1] to [0,1]
    parameters:
    w: float in Ω
    x: float array in [0,1]
    output:
    float array
    """
    return w*x*(1-x)

def exp_f(w,x):
    """
    E_w(ln|df/dx)|) - calculated using online integration calculator - map from Ω ⊆ [0,4] x R to R 
    """
    return 0.5*w*((np.sign(w-2*x*w)+1)*(np.log(abs(w-2*x*w))-1) -((np.sign(w-2*x*w)-1))*(np.log(abs(2*x-1)*w)-1))

mu = MCQSD(f,10**6,1000,[1.75,4],[0,1])[0]
top_lyap(exp_f, [1.75,4], mu, [0,1])

n=500
test = prob_mat(n,f,[1.75,4],[0,1])
mu_ulam = stationarydist(test)[0]
top_lyap(exp_f, [1.75,4], mu_ulam, [0,1])



#method 2 approximating the Birkhoff sums

def birkhoff(f,diff_f,n,Ω,domain):
    """
    approximates Birkhoff sum for top Lyapunov exponent
    parameters:
    f: map from Ω x domain to domain
    diff_f: partial derivative of f w.r.t. x
    n: integer >> 1
    Ω: interval in R from which noise values are drawn from uniformly
    domain: interval in R
    """
    omega = np.random.uniform(Ω[0],Ω[1],n+1)
    birk_sum = 0
    phi_i = np.random.uniform(domain[0],domain[1])
    for i in range(n):
        phi_i = f(omega[i],phi_i)
        birk_sum += np.log(abs(diff_f(omega[i],phi_i)))
    return birk_sum/n

# example for a random logistic map

def f(w,x):
    return w*x*(1-x)
def df_dx(w,x):
    return w-2*w*x
    
birkhoff(f,df_dx,1000000,[1.75,4],[0,1])
