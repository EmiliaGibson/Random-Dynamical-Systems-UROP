import numpy as np
import matplotlib.pyplot as plt
from numpy import linalg as LA
from scipy import sparse
from scipy.sparse.linalg import eigs


# Monte Carlo method for QSD
def MCQSD(g,N,N2,domain,Ω):
    '''
    parameters: 
    g  : function outputting a map from Ω x domain --> domain, with escape  
    N  : integer - length of trajectory  
    N2  : integer - number of subintervals to divide domain into
    domain : interval in R 
    Ω  : interval in R from which noise values are to be sampled from uniformly
    output:
    count  : QSD
    survivals  : Survival rate of QSM
    '''
    partition = np.linspace(domain[0],domain[1],N2+1)
    
    #initalize output
    count=np.zeros(N2)
    
    
    #list of previous points of trajectory inside domain
    x_tracker=np.zeros(N+1)
    x_tracker[0] = np.random.uniform(domain[0],domain[1])
    
    #store killing times
    killing_times=[0]
    
    intervals = np.zeros((N2,2))
    for j in range(N2):
        intervals[j]= partition[j], partition[j+1]
    
    
    for n in range(N):
        #print percentage of for loops completed
        progressbar(n,N)
        
        #move trajectory forward one timestep 
        newx = g(np.random.uniform(Ω[0],Ω[1]),x_tracker[n])[0]
        
        #find out which subinterval the new point lies, if any 
        add =  np.ndarray.flatten(indicator_fast(np.asarray([newx]),intervals))
        
        #record point's location (in domain)
        count += add
        
        #if point lies outside domain, resample from trajectory history using empirical distribution
        if np.sum(add)==0:
            killing_times.append(n+1)
            x_tracker[n+1] = x_tracker[int(n*np.random.uniform(0,1))]
        
        else:
            x_tracker[n+1] = newx
    #calculate survival rate        
    survivals = np.mean([killing_times[i+1]-killing_times[i] for i in range(len(killing_times)-1)])
    
    #calculate aprroximate QSD
    count = count/(N*((partition[1]-partition[0])**2))
    return count, survivals    


# a few maps 

def g(omega,x):
    """
    maps from [-1,1]x[-1,1] to R
    parameters:
    omega: a random sample of size 1 drawn from a uniform[-1,1] dist
    x: float in [-1,1]
    output:
    float : value of mapping of x
    """
    return 2*x + omega

def g2(omega,x):
    """
    maps from [-1,1]x[-2,2] to R
    parameters:
    omega: a random sample of size 1 drawn from a uniform[-1,1] dist
    x: float in [-2,2]
    output:
    float in R: value of mapping of x
    """
    return np.power(x,3) + 6*omega
def g3(omega,x):
    """
    maps from [-m,m]x[0,1] to R
    parameters:
    omega: a random sample of size 1 drawn from a uniform [-m,m] dist
    x: float in [0,1]
    output:
    float in R: value of mapping of x
    """
    return 1/(1+np.exp(-x)) + omega

def g4(omega, x):
    """
    maps from [-1/4,1/4]x[0,1] to R
    parameters:
    omega: a random sample of size 1 drawn from a uniform [-m,m] dist
    x: float in [0,1]
    output:
    float in R: value of mapping of x
    """
    return np.exp(1)*x/(1+(np.exp(1)-1)*x) + omega

def g5(omega, x):
    return x + np.power(x,3) + omega


#plotting example
test = MCQSD(g, 10**7,1000)
plt.plot(np.linspace(-1,1,len(test[0])),test[0]/np.trapz(test[0],np.linspace(-1,1,len(test[0]))))
plt.show()
