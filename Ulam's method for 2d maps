import numpy as np
import matplotlib.pyplot as plt
from numpy import linalg as LA
import matplotlib.colors as colors
from mpl_toolkits.mplot3d import Axes3D
from scipy import sparse
from scipy.sparse.linalg import eigs

# Ulam's method

def progressbar(i,n,refresh_rate = 1, i_start = 0):
    '''
    Approximates how far through the computation you are, by showing a percentage of total loops that have been computed
    i = loop index
    n = amount of iterations (max loop index + 1 if i_start = 0)
    refresh_rate = how often you would like to update the percentage (useful)
    i_start = start value of loop
    '''
    output = (i-i_start)/refresh_rate
    if (int(output)==output):
        print(str(np.round((i+1-i_start)/n*100,2))+'%', end ="\r")

        
def indicator_2D(xx,yy,A,B):
    """
    indicator function for R^2
    parameters:
    xx,yy: arrays of x and y coords *of same dimensions
    A: bounds of 'x' coords
    B: bounds of 'y' coords
    output:
    array of ones and zeros 
    """
    a , b = A[0], A[1]
    c , d = B[0], B[1]
    out1 = (np.heaviside(xx-a,0) - np.heaviside(xx-b,0))
    out2 = (np.heaviside(yy-c,0) - np.heaviside(yy-d,0))
    return  np.minimum(out1,out2)


def p_2D(xx,yy,A,B,f,Ω,s=s,b=b):
    """
    Markov kernel for R^2
    parameters:
    xx,yy: square meshgrids of same dimensions
    A: bounds of 'x' coord
    B: bounds of 'y' coord
    f: function mapping from Ω x R x R to R x R
    Ω: interval in R from which noise values are drawn form uniformly 
    output:
    float array with shape of xx and yy
    """
    shape = np.shape(xx)
    omega= np.linspace(Ω[0],Ω[1],100)
    xx, yy = np.ndarray.flatten(xx), np.ndarray.flatten(yy)
    xys = f3(omega,np.transpose([xx,]),np.transpose([yy,]),s,b)[0]
    z = indicator_2D(xys[0],xys[1],A,B)
    return np.reshape(1/(Ω[1]-Ω[0])*np.trapz(z,omega,axis=1),shape)

def double_Integral(xmin, xmax, ymin, ymax, nx, ny, A):
    """
    Integration using trapexium rule in 2D taken from: 
    https://stackoverflow.com/questions/20668689/integrating-2d-samples-on-a-rectangular-grid-using-scipy
    parameters:
    xmin, xmax: integral bounds of 'x' coord
    ymin, ymax: integral bounds of 'y' coord
    nx ,ny: number of subintervals of x and y resp.
    A: meshgrid of points to be integrated over
    output:
    float
    """
    dS = ((xmax-xmin)/(nx-1)) * ((ymax-ymin)/(ny-1))
    A_Internal = A[1:-1, 1:-1]
    # sides: up, down, left, right
    (A_u, A_d, A_l, A_r) = (A[0, 1:-1], A[-1, 1:-1], A[1:-1, 0], A[1:-1, -1])
    # corners
    (A_ul, A_ur, A_dl, A_dr) = (A[0, 0], A[0, -1], A[-1, 0], A[-1, -1])
    return dS * (np.sum(A_Internal)\
              + 0.5 * (np.sum(A_u) + np.sum(A_d) + np.sum(A_l) + np.sum(A_r))\
              + 0.25 * (A_ul + A_ur + A_dl + A_dr))

def prob_mat_2D(n,f,Ω,domain):
    """
    Perron-Frobenius operator
    parameters:
    n : integer, n^2 = number of boxes to divide the domain into
    f: function outputting: a map from Ω x domain to domain
    Ω: interval in R from which noise values are drawn form uniformly    
    domain: interval in R^2
    output:
    n^2 x n^2  stochastic matrix
    """
    #area of each cell
    h =(domain[1][1]-domain[1][0])/n*(domain[0][1]-domain[0][0])/n
    partition_x = np.linspace(domain[0][0],domain[0][1],n+1)
    partition_y = np.linspace(domain[1][0],domain[1][1],n+1)
    out = np.zeros((n**2, n**2))
    count=-1
    for k in range(n):
        for l in range(n):
            A2 = (partition_x[k], partition_x[k+1])
            B2 = (partition_y[l], partition_y[l+1])
            x = np.linspace(A2[0], A2[1], 10)
            y = np.linspace(B2[0], B2[1], 10)
            xx,yy = np.meshgrid(x,y)
            count+=1
            count2 = -1
            progressbar(count,n**2)
            for i in range(n):
                for j in range(n):
                    count2 += 1
                    A = (partition_x[i],partition_x[i+1])
                    B = (partition_y[j], partition_y[j+1])
                    zz = p_2D(xx,yy,A,B,f,Ω,s,b)
                    out[count,count2] = double_Integral(A2[0],A2[1],B2[0], B2[1],10,10, zz)/h
            
    return out




def indicator_2D_fast(xx,yy,boxes):
    """
    indicator function for R^2
    parameters:
    xx,yy: arrays of x and y coords *of same dimensions
    boxes: intervals in R^2 to pass omdocator function through
    output:
    float array of ones and zeros 
    """
    a , b = boxes[:,0][np.newaxis].T, boxes[:,1][np.newaxis].T
    c , d = boxes[:,2][np.newaxis].T, boxes[:,3][np.newaxis].T
    xx, yy = np.ndarray.flatten(xx), np.ndarray.flatten(yy)
    out1 = (np.heaviside(xx-a,0) - np.heaviside(xx-b,0))
    out2 = (np.heaviside(yy-c,0) - np.heaviside(yy-d,0))
    return  np.minimum(out1,out2)


def p_2D_fast(xx,yy,boxes,f,Ω,s=s,b=b):
    """
    #approximate markov kernel at single point 
    parameters:
    xx,yy: square meshgrid
    boxes: intervals in R^2 to pass omdocator function through
    f: function mapping from ΩxRxR to RxR
    Ω: interval in R from which noise values are drawn form uniformly 
    s,b: parameters for f
    output:
    float array 
    """
    omega= np.linspace(Ω[0],Ω[1],100)
    xx, yy = np.ndarray.flatten(xx), np.ndarray.flatten(yy)
    xys = f(omega,np.transpose([xx,]),np.transpose([yy,]),s,b)[0]
    z = indicator_2D_fast(xys[0],xys[1],boxes)
    return 1/(Ω[1]-Ω[0])*np.trapz(z,omega,axis=1)




def prob_mat_2D_alt(n,f,n2,Ω,domain):
    """
    Perron-Frobenius operator
    parameters:
    n : integer, n^2 = number of boxes to divide the domain into
    f: function outputting: a map from Ω x domain to domain
    n2: integer, number of points to approximate markov kernel from
    Ω: interval in R from which noise values are drawn form uniformly    
    domain: interval in R^2
    output:
    n^2 x n^2  stochastic matrix
    """    
    
    #create partitions
    partition_x = np.linspace(domain[0][0],domain[0][1],n+1)
    partition_y = np.linspace(domain[1][0],domain[1][1],n+1)
    
    #initialise output matrix
    out = np.zeros((n**2, n**2)) 
    
    #get boxes of domain
    boxes = np.zeros((n**2,4))
    count = -1
    for l in range(n):
        for m in range(n):
            count+=1
            boxes[count,:] = (partition_x[l], partition_x[l+1],partition_y[m], partition_y[m+1])
            
            
    for i in range(n**2):
        AB = boxes[i]
        ave = np.zeros((n2,n**2))
        progressbar(i,n**2)
        for j in range(n2):
            x = np.random.uniform(AB[0], AB[1],1)
            y = np.random.uniform(AB[2], AB[3],1) 
            ave[j,:] =p_2D_fast(x,y,boxes,f,Ω,s,b)
        out[i,:]= np.mean(ave,axis=0)
    return out


def stationarydist_2D(mat):
     """
     gets right eigenvector of input matrix corresponding to evalue 1, reshaped into a 2d matrox
     parameters:
     mat : 2d float array with dimensions n^2 x n^2
     outputs: 2d float array with dimensions n x n
     """
    mat =  sparse.csr_matrix(mat)   
    dim = int(np.sqrt(np.shape(mat)[0]))
    evals,evecs = eigs(np.transpose(mat))
    index = np.argmax(evals)
    
    #check eigenvalue is indeed 1
    print(evals[index])
    
    return np.fliplr((np.abs(np.reshape(evecs[:,index],(dim,dim)))).T)
    
    
# example
s=1
b=1
def f3(omega,y1,th1,s=s,b=1):
    """ 
    maps from [-1,1]x[-0.022s,0.022s]x[0,1] to [-0.022s,0.022s]x[0,1]
    output constained to a cylinder
    parameters:
    omega: a random sample drawn from uniform[-1,1] dist
    y1: array of 'height' coords   
    th1: array of 'angle' coords
    s,b : floats
    outputs:
    [y1,th1]: value of mapping
#    (-2(s+0.001),2(s+0.001)) : min, max values of domain of mapping of 'x' coord- to be used in later functions
#    (0,1) : min, max values of domain of mapping of 'y' coord- to be used in later functions    
    """
    y1 = y1/2  +s*omega*(np.sin(np.pi*th1)**2+0.1)*0.01
    th1 = np.mod( b*y1+th1,1)
    return [y1,th1], (-2*(s*1.1)*0.01,2*(s*1.1)*0.01), (0,1)
    
s=1 
b=1 
test = prob_mat_2D(25,f3,[-1,1],[(-2*(s*1.1)*0.01,2*(s*1.1)*0.01), (0,1)])
d = stationarydist_2D(test)
test2 = prob_mat_2D_alt(50,f3,25,[-1,1],[(-2*(s*1.1)*0.01,2*(s*1.1)*0.01), (0,1)])
d2 = stationarydist_2D(test2)

# plotting
#color maps of approximated stationary measures using log color scale 
fig, ax = plt.subplots(1,1,figsize=(6,5))
img = ax.imshow(d.T,cmap=plt.cm.jet,extent=[-1,1,-1.5,1.5],norm=colors.LogNorm(vmin=1e-4,vmax=np.max(d)))
y_label_list = np.linspace(-0.02*s,0.02*s,5)
x_label_list = np.linspace(0,1,5)
ax.set_yticks(np.linspace(-1.5,1.5,5))
ax.set_xticks(np.linspace(-1,1,5))
ax.set_yticklabels(y_label_list)
ax.set_xticklabels(x_label_list)

fig, ax = plt.subplots(1,1,figsize=(6,5))
img = ax.imshow(d2.T,cmap=plt.cm.jet,extent=[-1,1,-1.5,1.5],norm=colors.LogNorm(vmin=1e-4,vmax=np.max(d2)))
y_label_list = np.linspace(-0.02*s,0.02*s,5)
x_label_list = np.linspace(0,1,5)
ax.set_yticks(np.linspace(-1.5,1.5,5))
ax.set_xticks(np.linspace(-1,1,5))
ax.set_yticklabels(y_label_list)
ax.set_xticklabels(x_label_list)
